<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_191) on Sat Apr 27 10:16:39 ADT 2019 -->
<title>CarpetExpression</title>
<meta name="date" content="2019-04-27">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CarpetExpression";
        }
    }
    catch(err) {
    }
//-->
var methods = {"i0":10,"i1":10,"i2":10,"i3":10,"i4":9,"i5":10,"i6":9,"i7":10};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">carpet.script</div>
<h2 title="Class CarpetExpression" class="title">Class CarpetExpression</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>carpet.script.CarpetExpression</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre>public class <span class="typeNameLabel">CarpetExpression</span>
extends java.lang.Object</pre>
<div class="block"><h1>Minecraft specific API and <code>scarpet</code> language add-ons and commands</h1>
 <p>Here is the gist of the Minecraft related functions. Otherwise the CarpetScript could live without Minecraft.</p>
 <h2>Dimension issues</h2>
 <p>One note, which is important is that most of the calls for entities and blocks
 would refer to the current dimension of the caller, meaning, that if we for example
 list all the players using <code>player('all')</code> function, if a player is in the
 other dimension, calls to entities and blocks around that player would point incorrectly.
 Moreover, running commandblocks in the spawn chunks would mean that commands will always
 refer to the overworld blocks and entities.
 In case you would want to run commands across all dimensions, just run three of them, using
 <code>/execute in overworld/the_nether/the_end run script run ...</code> and query
 players using <code>player('*')</code>, which only returns players in current dimension.</p></div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#CarpetExpression-java.lang.String-net.minecraft.command.CommandSource-net.minecraft.util.math.BlockPos-">CarpetExpression</a></span>(java.lang.String&nbsp;expression,
                net.minecraft.command.CommandSource&nbsp;source,
                net.minecraft.util.math.BlockPos&nbsp;origin)</code>
<div class="block">.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_AuxiliaryAspects--">API_AuxiliaryAspects</a></span>()</code>
<div class="block">Auxiliary aspects</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_BlockManipulation--">API_BlockManipulation</a></span>()</code>
<div class="block">Blocks / World API</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_EntityManipulation--">API_EntityManipulation</a></span>()</code>
<div class="block">Entity API</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#API_IteratingOverAreasOfBlocks--">API_IteratingOverAreasOfBlocks</a></span>()</code>
<div class="block">Iterating over larger areas of blocks</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>static void</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#BreakExecutionOfAllScriptsWithCommands-boolean-">BreakExecutionOfAllScriptsWithCommands</a></span>(boolean&nbsp;doStop)</code>
<div class="block"><code>script stop/script resume</code> command</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#fillAndScanCommand-int-int-int-">fillAndScanCommand</a></span>(int&nbsp;x,
                  int&nbsp;y,
                  int&nbsp;z)</code>
<div class="block"><code>/script scan</code>, <code>/script scan</code> and <code>/script outline</code> commands</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#invokeGlobalFunctionCommand-net.minecraft.command.CommandSource-java.lang.String-java.util.List-java.lang.String-">invokeGlobalFunctionCommand</a></span>(net.minecraft.command.CommandSource&nbsp;source,
                           java.lang.String&nbsp;call,
                           java.util.List&lt;java.lang.Integer&gt;&nbsp;coords,
                           java.lang.String&nbsp;arg)</code>
<div class="block"><code>/script invoke / invokepoint / invokearea</code>, <code>/script globals</code> commands</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../carpet/script/CarpetExpression.html#scriptRunCommand-net.minecraft.util.math.BlockPos-">scriptRunCommand</a></span>(net.minecraft.util.math.BlockPos&nbsp;pos)</code>
<div class="block"><code>/script run</code> command</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="CarpetExpression-java.lang.String-net.minecraft.command.CommandSource-net.minecraft.util.math.BlockPos-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CarpetExpression</h4>
<pre>public&nbsp;CarpetExpression(java.lang.String&nbsp;expression,
                        net.minecraft.command.CommandSource&nbsp;source,
                        net.minecraft.util.math.BlockPos&nbsp;origin)</pre>
<div class="block"><h1>.</h1></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>expression</code> - expression</dd>
<dd><code>source</code> - source</dd>
<dd><code>origin</code> - origin</dd>
</dl>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="API_AuxiliaryAspects--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_AuxiliaryAspects</h4>
<pre>public&nbsp;void&nbsp;API_AuxiliaryAspects()</pre>
<div class="block"><h1>Auxiliary aspects</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>Collection of other methods that control smaller, yet still important aspects of the game</p>
 <h2>Sounds</h2>
 <h3><code>sound(name, pos, volume?, pitch?)</code></h3>
 <p>Plays a specific sound <code>name</code>, at block or position <code>pos</code>, with optional
 <code>volume</code> and modified <code>pitch</code>. <code>pos</code> can be either a block, triple of coords,
 or a list of thee numbers. Uses the same options as a corresponding <code>playsound</code> command.</p>
 <h2>Particles</h2>
 <h3><code>particle(name, pos, count?. spread?, speed?, playername?)</code></h3>
 <p>Renders a cloud of particles <code>name</code> centered around <code>pos</code> position, by default
 <code>count</code> 10 of them, default <code>speed</code> of 0, and to all players nearby, but these
 options can be changed via optional arguments. Follow vanilla <code>/particle</code> command on details on those
 options. Valid particle names are for example
 <code>'angry_villager', 'item diamond', 'block stone', 'dust 0.8 0.1 0.1 4'</code></p>
 <h3><code>particle_line(name, pos, pos2, density?)</code></h3>
 <p>Renders a line of particles from point <code>pos</code> to <code>pos2</code> with supplied density (defaults 1),
 which indicates how far part you would want particles to appear, so <code>0.1</code> means one every 10cm.</p>
 <h3><code>particle_rect(name, pos, pos2, density?)</code></h3>
 <p>Renders a cuboid of particles between point <code>pos</code> to <code>pos2</code> with supplied density.</p>
 <h2>System function</h2>
 <h3><code>print(expr)</code></h3>
 <p>Displays the result of the expression to the chat. Overrides default <code>scarpet</code> behaviour of
 sending everyting to stderr.</p>
 <h3><code>run(expr)</code></h3>
 <p>Runs a command from the string result of the <code>expr</code> expression, and returns its success count</p>
 <h3><code>save()</code></h3>
 <p>Performs autosave, saves all chunks, player data, etc. Useful for programs where autosave is disabled
 due to performance reasons and saves the world only on demand.</p>
 <h3><code>tick_time()</code></h3>
 <p>Returns game tick counter. Can be used to run certain operations every n-th ticks, or to count in-game time</p>
 <h3><code>game_tick(mstime?)</code></h3>
 <p>Causes game to run for one tick. By default runs it and returns control to the program, but can optionally
 accept expected tick length, in milliseconds. You can't use it to permanently change the game speed, but
 setting longer commands with custom tick speeds can be interrupted via <code>/script stop</code> command</p>
 <pre>
 loop(1000,tick())  // runs the game as fast as it can for 1000 ticks
 loop(1000,tick(100)) // runs the game twice as slow for 1000 ticks
 </pre>
 <h3><code>current_dimension()</code></h3>
 <p>Returns current dimension that scripts run in.</p>
 <h3><code>plop(pos, what)</code></h3>
 <p>Plops a structure or a feature at a given <code>pos</code>, so block, triple position coordinates
 or a list of coordinates. To <code>what</code> gets plopped and exactly where it often depends on the
 feature or structure itself. For example, all structures are chunk aligned, and often span multiple chunks.
 Repeated calls to plop a structure in the same chunk would result either in the same strucuture generated on
 top of each other, or with different state, but same position. Most
 structures generate at specific altitudes, which are hardcoded, or with certain blocks around them. API will cancel
 all extra position / biome / random requirements for structure / feature placement, but some hardcoded limitations
 may still cause some of strucutures/features not to place. Some features require special blocks to be present, like
 coral -&gt; water or ice spikes -&gt; snow block, and for some features, like fossils, placement is all sorts of
 messed up.</p>
 <p>
 All generated structures will retain their properties, like mob spawning, however in many cases the world / dimension
 itself has certain rules to spawn mobs, like plopping a nether fortress in the overworld will not spawn nether mobs
 because nether mobs can spawn only in the nether, but plopped in the nether - will behave like a valid nether
 fortress.</p>
 <p><code>plop</code>  will not use world random number generator to generate structures and features, but its own.
 This has a benefit that they will generate properly randomly, not the same time every time</p>
 <p>Structure list:</p>
 <ul>

     <li><code>monument</code>: Ocean Monument. Generates at fixed Y coordinate, surrounds itself with water.</li>
     <li><code>fortress</code>: Nether Fortress. Altitude varies, but its bounded by the code.</li>
     <li><code>mansion</code>: Woodland Mansion</li>
     <li><code>jungle_temple</code>: Jungle Temple</li>
     <li><code>desert_temple</code>: Desert Temple. Generates at fixed Y altitude.</li>
     <li><code>end_city</code>: End City with Shulkers</li>
     <li><code>igloo</code>: Igloo</li>
     <li><code>shipwreck</code>: Shipwreck, version1?</li>
     <li><code>shipwreck2</code>: Shipwreck, version2?</li>
     <li><code>witchhut</code></li>
     <li><code>oceanruin, oceanruin_small, oceanruin_tall</code>: Stone variants of ocean ruins.</li>
     <li><code>oceanruin_warm, oceanruin_warm_small, oceanruin_warm_tall</code>: Sandstone variants of ocean ruins.</li>
     <li><code>treasure</code>: A treasure chest. Yes, its a whole structure.</li>
     <li><code>mineshaft</code>: A mineshaft.</li>
     <li><code>mineshaft_mesa</code>: A Mesa (Badlands) version of a mineshaft.</li>
     <li><code>village</code>: Plains, oak village.</li>
     <li><code>village_desert</code>: Desert, sandstone village.</li>
     <li><code>village_savanna</code>: Savanna, acacia village.</li>
     <li><code>village_taiga</code>: Taiga, spruce village.</li>
 </ul>
 <p>Feature list:</p>
 <ul>
     <li><code>oak</code></li>
     <li><code>oak_large</code>: oak with branches.</li>
     <li><code>birch</code></li>
     <li><code>birch_large</code>: tall variant of birch tree.</li>
     <li><code>shrub</code>: low bushes that grow in jungles.</li>
     <li><code>shrub_acacia</code>: low bush but configured with acacia</li>
     <li><code>shrub_snowy</code>: low bush with white blocks</li>
     <li><code>jungle</code>: a tree</li>
     <li><code>spruce_matchstick</code>: tall spruce with minimal leafage.</li>
     <li><code>dark_oak</code></li>
     <li><code>acacia</code></li>
     <li><code>spruce</code></li>
     <li><code>oak_swamp</code>: oak with more leaves and vines.</li>
     <li><code>jungle_large</code>: 2x2 jungle tree</li>
     <li><code>spruce_matchstick_large</code>: 2x2 spruce tree with minimal leafage</li>
     <li><code>spruce_large</code>: 2x2 spruce tree</li>
     <li><code>well</code>: desert well</li>
     <li><code>grass</code>: a few spots of tall grass</li>
     <li><code>grass_jungle</code>: little bushier grass feature</li>
     <li><code>fern</code>: a few random ferns</li>
     <li><code>cactus</code>: random cacti</li>
     <li><code>dead_bush</code>: a few random dead bushi</li>
     <li><code>fossils</code>: underground fossils, placement little wonky</li>
     <li><code>mushroom_brown</code>: large brown mushroom.</li>
     <li><code>mushroom_red</code>: large red mushroom.</li>
     <li><code>ice_spike</code>: ice spike. Require snow block below to place.</li>
     <li><code>glowstone</code>: glowstone cluster. Required netherrack above it.</li>
     <li><code>melon</code>: a patch of melons</li>
     <li><code>pumpkin</code>: a patch of pumpkins</li>
     <li><code>sugarcane</code></li>
     <li><code>lilypad</code></li>
     <li><code>dungeon</code>: Dungeon. These are hard to place, and fail often.</li>
     <li><code>iceberg</code>: Iceberg. Generate at sea level.</li>
     <li><code>iceberg_blue</code>: Blue ice iceberg.</li>
     <li><code>lake</code></li>
     <li><code>lava_lake</code></li>
     <li><code>end_island</code></li>
     <li><code>chorus</code>: Chorus plant. Require endstone to place.</li>
     <li><code>sea_grass</code>: a patch of sea grass. Require water.</li>
     <li><code>sea_grass_river</code>: a variant.</li>
     <li><code>kelp</code></li>
     <li><code>coral_tree, coral_mushroom, coral_claw</code>: various coral types, random color.</li>
     <li><code>coral</code>: random coral structure. Require water to spawn.</li>
     <li><code>sea_pickle</code></li>
     <li><code>boulder</code>: A rocky, mossy formation from a giant taiga biome. Doesn't update client properly,
     needs relogging.</li>
 </ul>
 </div></div>
</li>
</ul>
<a name="API_BlockManipulation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_BlockManipulation</h4>
<pre>public&nbsp;void&nbsp;API_BlockManipulation()</pre>
<div class="block"><h1>Blocks / World API</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <h2>Specifying blocks</h2>
 <h3><code>block(x, y, z), block(state)</code></h3>
 <p>Returns either a block from specified location, or block with a specific state
 (as used by <code>/setblock</code> command), so allowing for block properties etc.
 Blocks can be referenced everywhere by its simple name, but its only used in its default state</p>
 <pre>
 block('air')  =&gt; air
 block('iron_trapdoor[half=top]')  =&gt; iron_trapdoor
 block(0,0,0) == block('bedrock')  =&gt; 1
 </pre>
 <h2>World Manipulation</h2>
 <p>All the functions below can be used with block value, queried with coord triple, or 3-long list.
 All <code>pos</code> in the functions referenced below refer to either method of passing block position</p>
 <h3><code>set(pos, block, property?, value?, ...)</code></h3>
 <p>First part of the <code>set</code> function is either a coord triple, list of tree numbers, or other block
 with coordinates. Second part, <code>block</code> is either block value as a result of <code>block()</code> function
 string value indicating the block name, and optional <code>property - value</code> pairs for extra block properties.
 If <code>block</code> is specified only by name, then if a destination block is the same the <code>set</code> operation
 is skipped, otherwise is executed, for other potential extra properties</p>
 <p>The returned value is either the block state that has been set, or <code>false</code> if block setting was skipped</p>
 <pre>
 set(0,5,0,'bedrock')  =&gt; bedrock
 set(l(0,5,0), 'bedrock')  =&gt; bedrock
 set(block(0,5,0), 'bedrock')  =&gt; bedrock
 scan(0,5,0,0,0,0,set(_,'bedrock'))  =&gt; 1
 set(pos(players()), 'bedrock')  =&gt; bedrock
 set(0,0,0,'bedrock')  =&gt; 0   // or 1 in overworlds generated in 1.8 and before
 scan(0,100,0,20,20,20,set(_,'glass'))
     // filling the area with glass
 scan(0,100,0,20,20,20,set(_,block('glass')))
     // little bit faster due to internal caching of block state selectors
 b = block('glass'); scan(0,100,0,20,20,20,set(_,b))
     // yet another option, skips all parsing
 set(x,y,z,'iron_trapdoor')  // sets bottom iron trapdoor
 set(x,y,z,'iron_trapdoor[half=top]')  // Incorrect. sets bottom iron trapdoor - no parsing of properties
 set(x,y,z,'iron_trapdoor','half','top') // correct - top trapdoor
 set(x,y,z,block('iron_trapdoor[half=top]')) // also correct, block() provides extra parsing
 </pre>
 <h3><code>update(pos)</code></h3>
 <p>Causes a block update at position.</p>
 <h3><code>block_tick(pos)</code></h3>
 <p>Causes a block to tick at position.</p>
 <h3><code>random_tick(pos)</code></h3>
 <p>Causes a random tick at position.</p>

 <h2>Block and World querying</h2>

 <h3><code>pos(block), pos(entity)</code></h3>
 <p>Returns a triple of coordinates of a specified block or entity. Technically entities are queried with
 <code>query</code> function and the same can be achieved with <code>query(entity,'pos')</code>, but for simplicity
 <code>pos</code> allows to pass all positional objects.</p>
 <pre>
     pos(block(0,5,0))  =&gt; l(0,5,0)
     pos(players()) =&gt; l(12.3, 45.6, 32.05)
     pos(block('stone'))  =&gt; Error: Cannot fetch position of an unrealized block
 </pre>
 <h3><code>property(pos, name)</code></h3>
 <p>Returns property of block at <code>pos</code>, or specified by <code>block</code> argument. If a block doesn't
 have that property, <code>null</code> value is returned. Returned values are always strings. It is expected from
 the user to know what to expect and convert values to numbers using <code>number()</code> function or booleans
 using <code>bool()</code> function.</p>
 <pre>
     set(x,y,z,'iron_trapdoor','half','top'); property(x,y,z,'half')  =&gt; top
     set(x,y,z,'air'); property(x,y,z,'half')  =&gt; null
     property(block('iron_trapdoor[half=top]'),'half')  =&gt; top
     property(block('iron_trapdoor[half=top]'),'powered')  =&gt; false
     bool(property(block('iron_trapdoor[half=top]'),'powered'))  =&gt; 0
 </pre>

 <h3><code>solid(pos)</code></h3>
 <p>Boolean function, true of the block is solid</p>
 <h3> <code>air(pos)</code></h3>
 <p>Boolean function, true if a block is air.... or cave air...
 or void air.... or any other air they come up with.</p>
 <h3><code>liquid(pos)</code></h3>
 <p>Boolean function, true of the block is liquid, or liquidlogged</p>
 <h3><code>flammable(pos)</code></h3>
 <p>Boolean function, true of the block is flammable</p>
 <h3><code>transparent(pos)</code></h3>
 <p>Boolean function, true of the block is transparent</p>
 <h3><code>opacity(pos)</code></h3>
 <p>Numeric, returning opacity level of a block</p>
 <h3><code>blocks_daylight(pos)</code></h3>
 <p>Boolean function, true of the block blocks daylight</p>
 <h3><code>emitted_light(pos)</code></h3>
 <p>Numeric, returning light level emitted from block</p>
 <h3><code>light(pos)</code></h3>
 <p>Integer function, returning total light level at position</p>
 <h3><code>block_light(pos)</code></h3>
 <p>Integer function, returning block light at position. From torches and other light sources.</p>
 <h3><code>sky_light(pos)</code></h3>
 <p>Numeric function, returning sky light at position. From the sky access.</p>
 <h3><code>see_sky(pos)</code></h3>
 <p>Boolean function, returning true if the block can see sky.</p>
 <h3><code>hardness(pos)</code></h3>
 <p>Numeric function, indicating hardness of a block.</p>
 <h3><code>blast_resistance(pos)</code></h3>
 <p>Numeric function, indicating blast_resistance of a block.</p>

 <h3><code>top(type, x, z)</code></h3>
 <p>Returns the Y value of the topmost block at given x, z coords, according to the
 heightmap specified by <code>type</code>. Valid options are:</p>
 <ul>
     <li><code>light</code>: topmost light blocking block</li>
     <li><code>motion</code>: topmost motion blocking block</li>
     <li><code>terrain</code>: topmost motion blocking block except leaves</li>
     <li><code>ocean_floor</code>: topmost non-water block</li>
     <li><code>surface</code>: topmost surface block</li>
 </ul>
 <pre>
 top('motion', x, z)  =&gt; 63
 top('ocean_floor', x, z)  =&gt; 41
 </pre>
 <h3><code>loaded(pos)</code></h3>
 <p>Boolean function, true of the block is loaded. Normally <code>scarpet</code> doesn't check if operates on
 loaded area - the game will automatically load missing blocks. We see this as advantage.
 Vanilla <code>fill/clone</code> commands only check the specified corners for loadness.</p>
 <pre>
 loaded(pos(players()))  =&gt; 1
 loaded(100000,100,1000000)  =&gt; 0
 </pre>
 <h3><code>loaded_ep(pos)</code></h3>
 <p>Boolean function, true of the block is loaded and entity processing, as per 1.13.2</p>
 <h3><code>suffocates(pos)</code></h3>
 <p>Boolean function, true of the block causes suffocation.</p>
 <h3><code>power(pos)</code></h3>
 <p>Numeric function, returning redstone power level at position.</p>
 <h3><code>ticks_randomly(pos)</code></h3>
 <p>Boolean function, true if the block ticks randomly.</p>
 <h3><code>blocks_movement(pos)</code></h3>
 <p>Boolean function, true if block at position blocks movement.</p>
 <h3><code>block_sound(pos)</code></h3>
 <p>Returns the name of sound type made by the block at position. One of:</p>
 <ul>
     <li><code>wood     </code>  </li>
     <li><code>gravel   </code>  </li>
     <li><code>grass    </code>  </li>
     <li><code>stone    </code>  </li>
     <li><code>metal    </code>  </li>
     <li><code>glass    </code>  </li>
     <li><code>wool     </code>  </li>
     <li><code>sand     </code>  </li>
     <li><code>snow     </code>  </li>
     <li><code>ladder   </code>  </li>
     <li><code>anvil    </code>  </li>
     <li><code>slime    </code>  </li>
     <li><code>sea_grass</code>  </li>
     <li><code>coral    </code>  </li>
 </ul>
 <h3><code>material(pos)</code></h3>
 <p>Returns the name of material of the block at position. very useful to target a group of blocks. One of:</p>
 <ul>
     <li><code> air                </code>  </li>
     <li><code> void               </code>  </li>
     <li><code> portal             </code>  </li>
     <li><code> carpet             </code>  </li>
     <li><code> plant              </code>  </li>
     <li><code> water_plant        </code>  </li>
     <li><code> vine               </code>  </li>
     <li><code> sea_grass          </code>  </li>
     <li><code> water              </code>  </li>
     <li><code> bubble_column      </code>  </li>
     <li><code> lava               </code>  </li>
     <li><code> snow_layer         </code>  </li>
     <li><code> fire               </code>  </li>
     <li><code> redstone_bits      </code>  </li>
     <li><code> cobweb             </code>  </li>
     <li><code> redstone_lamp      </code>  </li>
     <li><code> clay               </code>  </li>
     <li><code> dirt               </code>  </li>
     <li><code> grass              </code>  </li>
     <li><code> packed_ice         </code>  </li>
     <li><code> sand               </code>  </li>
     <li><code> sponge             </code>  </li>
     <li><code> wood               </code>  </li>
     <li><code> wool               </code>  </li>
     <li><code> tnt                </code>  </li>
     <li><code> leaves             </code>  </li>
     <li><code> glass              </code>  </li>
     <li><code> ice                </code>  </li>
     <li><code> cactus             </code>  </li>
     <li><code> stone              </code>  </li>
     <li><code> iron               </code>  </li>
     <li><code> snow               </code>  </li>
     <li><code> anvil              </code>  </li>
     <li><code> barrier            </code>  </li>
     <li><code> piston             </code>  </li>
     <li><code> coral              </code>  </li>
     <li><code> gourd              </code>  </li>
     <li><code> dragon_egg         </code>  </li>
     <li><code> cake               </code>  </li>
 </ul>
 <h3><code>map_colour(pos)</code></h3>
 <p>Returns the map colour of a block at position. One of:</p>
 <ul>
     <li><code> air            </code>  </li>
     <li><code> grass          </code>  </li>
     <li><code> sand           </code>  </li>
     <li><code> wool           </code>  </li>
     <li><code> tnt            </code>  </li>
     <li><code> ice            </code>  </li>
     <li><code> iron           </code>  </li>
     <li><code> foliage        </code>  </li>
     <li><code> snow           </code>  </li>
     <li><code> clay           </code>  </li>
     <li><code> dirt           </code>  </li>
     <li><code> stone          </code>  </li>
     <li><code> water          </code>  </li>
     <li><code> wood           </code>  </li>
     <li><code> quartz         </code>  </li>
     <li><code> adobe          </code>  </li>
     <li><code> magenta        </code>  </li>
     <li><code> light_blue     </code>  </li>
     <li><code> yellow         </code>  </li>
     <li><code> lime           </code>  </li>
     <li><code> pink           </code>  </li>
     <li><code> gray           </code>  </li>
     <li><code> light_gray     </code>  </li>
     <li><code> cyan           </code>  </li>
     <li><code> purple         </code>  </li>
     <li><code> blue           </code>  </li>
     <li><code> brown          </code>  </li>
     <li><code> green          </code>  </li>
     <li><code> red            </code>  </li>
     <li><code> black          </code>  </li>
     <li><code> gold           </code>  </li>
     <li><code> diamond        </code>  </li>
     <li><code> lapis          </code>  </li>
     <li><code> emerald        </code>  </li>
     <li><code> obsidian       </code>  </li>
     <li><code> netherrack     </code>  </li>
     <li><code> white_terracotta          </code>  </li>
     <li><code> orange_terracotta         </code>  </li>
     <li><code> magenta_terracotta        </code>  </li>
     <li><code> light_blue_terracotta     </code>  </li>
     <li><code> yellow_terracotta         </code>  </li>
     <li><code> lime_terracotta           </code>  </li>
     <li><code> pink_terracotta           </code>  </li>
     <li><code> gray_terracotta           </code>  </li>
     <li><code> light_gray_terracotta     </code>  </li>
     <li><code> cyan_terracotta           </code>  </li>
     <li><code> purple_terracotta         </code>  </li>
     <li><code> blue_terracotta           </code>  </li>
     <li><code> brown_terracotta          </code>  </li>
     <li><code> green_terracotta          </code>  </li>
     <li><code> red_terracotta            </code>  </li>
     <li><code> black_terracotta          </code>  </li>
 </ul>
 </div></div>
</li>
</ul>
<a name="API_EntityManipulation--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_EntityManipulation</h4>
<pre>public&nbsp;void&nbsp;API_EntityManipulation()</pre>
<div class="block"><h1>Entity API</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <h2>Entity Selection</h2>
 <p>Entities have to be fetched before using them. Entities can also change their state between calls to the script
 if game happens either in between separate calls to the programs, or if the program calls <code>game_tick</code>
 on its own. In this case - entities would need to be re-fetched, or the code should account for entities getting dead</p>
 <h3><code>player(), player(type), player(name)</code></h3>
 <p>
 With no arguments, it returns the calling player or the player closest to the caller. Note that the main context
 will receive <code>p</code> variable pointing to this player. With <code>type</code> or <code>name</code> specified
 it will try first to match a type, returning a list of players matching a type, and if this fails, will assume its
 player name query retuning player with that name, or <code>null</code> if no player was found.
 With <code>'all'</code>, list of all players in the game, in all dimensions, so end user needs to be cautious, that
 you might be referring to wrong blocks and entities around the player in question.
 WIth <code>type = '*'</code> it returns all players in caller dimension, <code>'survival'</code> returns all survival
 and adventure players, <code>'creative'</code> returns all creative players, <code>'spectating'</code> returns all spectating
 players, and <code>'!spectating'</code>, all not-spectating players. If all fails,
 with <code>name</code>, the player in question, if is logged in.</p>
 <h3><code>entity_id(uuid), entity_id(id)</code></h3>
 <p>Fetching entities wither by their ID obtained via <code>entity ~ 'id'</code>, which is unique
 for a dimension and current world run, or by UUID, obtained via <code>entity ~ 'uuid'</code>.
 It returns null if no such entity
 is found. Safer way to 'store' entities between calls, as missing entities will be returning <code>null</code>.
 Both calls using UUID or numerical ID are <code>O(1)</code>, but obviously using UUIDs takes more memory and compute.</p>
 <h3><code>entity_list(type)</code></h3>
 <p>Returns global lists of entities in the current dimension of a specified type. Currently the following selectors are available:</p>
 <ul>
     <li><code>*</code>: all</li>
     <li><code>living</code></li>
     <li><code>items</code></li>
     <li><code>players</code></li>
     <li><code>!players</code></li>
 </ul>

 <h3><code>entity_area(type, cx, cy, cz, dx, dy, dz)</code></h3>
 <p>Returns entities of a specified type in an area centered on <code>cx, cy, cz</code> and
 at most <code>dx, dy, dz</code> blocks away from the center point. Uses same selectors as <code>entities_list</code></p>

 <h3><code>entity_selector(selector)</code></h3>
 <p>Returns entities satisfying given vanilla entity selector. Most complex among all the methods of selecting
 entities, but the most capable. Selectors are cached so should be as fast as other methods of selecting entities.</p>

 <h2>Entity Manipulation</h2>

 <p>Unlike with blocks, that use plethora of vastly different querying functions, entities are queried with
 <code>query</code> function and altered via <code>modify</code> function. Type of information needed or
 values to be modified are different for each call</p>
 <h3><code>query(e,'removed')</code></h3>
 <p>Boolean. True if the entity is removed</p>
 <h3><code>query(e,'id')</code></h3>
 <p>Returns numerical id of the entity. Most efficient way to keep track of entites in a script. Ids are only unique
 within current game session (ids are not preserved between restarts), and dimension (each dimension has its own ids
 which can overlap. </p>
 <h3><code>query(e,'uuid')</code></h3>
 <p>Returns UUID (unique id) of the entity. Can be used to access entities with the other vanilla commands and remains unique
 regardless of the dimension, and is preserved between game restarts.
 Apparently players cannot be accessed via UUID, but name instead.</p>
 <pre>
 map(entities_area('*',x,y,z,30,30,30),run('kill '+query(_,'id'))) // doesn't kill the player
 </pre>
 <h3><code>query(e,'pos')</code></h3>
 <p>Triple of entity position</p>
 <h3><code>query(e,'x'), query(e,'y'), query(e,'z')</code></h3>
 <p>Respective entity coordinate</p>
 <h3><code>query(e,'pitch'), query(e,'yaw')</code></h3>
 <p>Pitch and Yaw or where entity is looking.</p>
 <h3><code>query(e,'motion')</code></h3>
 <p>Triple of entity motion vector, <code>l(motion_x, motion_y, motion_z)</code></p>
 <h3><code>query(e,'motion_x'), query(e,'motion_y'), query(e,'motion_z')</code></h3>
 <p>Respective component of the motion vector</p>
 <h3><code>query(e,'name'), query(e,'custom_name'), query(e,'type')</code></h3>
 <p>String of entity name</p>
 <pre>
 query(e,'name')  =&gt; Leatherworker
 query(e,'custom_name')  =&gt; null
 query(e,'type')  =&gt; villager
 </pre>
 <h3><code>query(e,'is_riding')</code></h3>
 <p>Boolean. True if riding another entity.</p>
 <h3><code>query(e,'is_ridden')</code></h3>
 <p>Boolean. True if another entity is riding it.</p>
 <h3><code>query(e,'passengers')</code></h3>
 <p>List of entities riding the entity.</p>
 <h3><code>query(e,'mount')</code></h3>
 <p>Entity that <code>e</code> rides.</p>
 <h3><code>query(e,'tags')</code></h3>
 <p>List of entity tags.</p>
 <h3><code>query(e,'has_tags',tag)</code></h3>
 <p>Boolean, True if the entity is marked with <code>tag</code>.</p>
 <h3><code>query(e,'is_burning')</code></h3>
 <p>Boolean, True if the entity is burning.</p>
 <h3><code>query(e,'fire')</code></h3>
 <p>Number of remaining ticks of being on fire.</p>
 <h3><code>query(e,'silent')</code></h3>
 <p>Boolean, True if the entity is silent.</p>
 <h3><code>query(e,'gravity')</code></h3>
 <p>Boolean, True if the entity is affected y gravity, like most entities do.</p>
 <h3><code>query(e,'immune_to_fire')</code></h3>
 <p>Boolean, True if the entity is immune to fire.</p>
 <h3><code>query(e,'dimension')</code></h3>
 <p>Name of the dimension entity is in.</p>
 <h3><code>query(e,'height')</code></h3>
 <p>Height of the entity.</p>
 <h3><code>query(e,'width')</code></h3>
 <p>Width of the entity.</p>
 <h3><code>query(e,'eye_height')</code></h3>
 <p>Eye height of the entity.</p>
 <h3><code>query(e,'age')</code></h3>
 <p>Age, in ticks, of the entity, i.e. how long it existed.</p>
 <h3><code>query(e,'item')</code></h3>
 <p>Name of the item if its an item entity, <code>null</code> otherwise</p>
 <h3><code>query(e,'count')</code></h3>
 <p>Number of items in a stack from item entity.<code>null</code> otherwise</p>
 <h3><code>query(e,'is_baby')</code></h3>
 <p>Boolean, true if its a baby.</p>
 <h3><code>query(e,'target')</code></h3>
 <p>Returns mob's attack target or null if none or not applicable.</p>
 <h3><code>query(e,'home')</code></h3>
 <p>Returns creature's home position or null if none or not applicable.</p>
 <h3><code>query(e,'sneaking')</code></h3>
 <p>Boolean, true if entity is sneaking.</p>
 <h3><code>query(e,'sprinting')</code></h3>
 <p>Boolean, true if entity is sprinting.</p>
 <h3><code>query(e,'swimming')</code></h3>
 <p>Boolean, true if entity is swimming.</p>
 <h3><code>query(e,'gamemode')</code></h3>
 <p>String with gamemode, or <code>null</code> if not a player.</p>
 <h3><code>query(e,'gamemode_id')</code></h3>
 <p>Good'ol gamemode id, or null if not a player.</p>
 <h3><code>query(e,'effect',name?)</code></h3>
 <p>Without extra arguments, it returns list of effect active on a living entity.
 Each entry is a triple of short effect name, amplifier, and remaining duration.
 With an argument, if the living entity has not that potion active, returns <code>null</code>, otherwise
 return a tuple of amplifier and remaining duration</p>
 <pre>
 query(p,'effect')  =&gt; [[haste, 0, 177], [speed, 0, 177]]
 query(p,'effect','haste')  =&gt; [0, 177]
 query(p,'effect','resistance')  =&gt; null
 </pre>
 <h3><code>query(e,'health')</code></h3>
 <p>Number indicating remaining entity health, or <code>null</code> if not applicable.</p>
 <h3><code>query(e,'holds',slot?)</code></h3>
 <p>Returns triple of short name, stack count, and NBT of item held in <code>slot</code>.
 Available options for <code>slot</code> are:</p>
 <ul>
     <li><code>main</code></li>
     <li><code>offhand</code></li>
     <li><code>head</code></li>
     <li><code>chest</code></li>
     <li><code>legs</code></li>
     <li><code>feet</code></li>
 </ul>
 <p>If <code>slot</code> is not specified, it defaults to the main hand.</p>
 <h3><code>query(e,'nbt',path?)</code></h3>
 <p>Returns full NBT of the entity. If path is specified, it fetches only that portion of the NBT,
 that corresponds to the path. For specification of <code>path</code> attribute, consult
 vanilla <code>/data get entity</code> command.</p>
 <p>Note that calls to <code>nbt</code> are considerably more expensive comparing to other
 calls in Minecraft API, and should only be used when there is no other option. Also returned
 NBT is just a string to any retrieval of information post can currently only be done with matching
 operator <code>~</code>. With time we are hoping not to support the <code>'nbt'</code> call better,
 but rather to fill the API, so that <code>'nbt'</code> calls are not needed</p>
 <h2>Entity Modification</h2>
 <p>Like with entity querying, entity modifications happen through one function. Most position and movements
 modifications don't work currently on players as their position is controlled by clients.</p>
 <p>Currently there is no ability to modify NBT directly, but you could always use <code>run('data modify entity</code></p>
 <h3><code>modify(e,'remove')</code></h3>
 <p>Removes (not kills) entity from the game.</p>
 <h3><code>modify(e,'kill')</code></h3>
 <p>Kills the entity.</p>
 <h3><code>modify(e, 'pos', x, y, z), modify(e, 'pos', l(x,y,z) )</code></h3>
 <p>Moves the entity to a specified coords.</p>
 <h3><code>modify(e, 'x', x), modify(e, 'y', y), modify(e, 'z', z)</code></h3>
 <p>Moves the entity in.... one direction.</p>
 <h3><code>modify(e, 'pitch', pitch), modify(e, 'yaw', yaw)</code></h3>
 <p>Changes entity's pitch or yaw.</p>
 <h3><code>modify(e, 'move', x, y, z), modify(e, 'move', l(x,y,z) )</code></h3>
 <p>Moves th entity by a vector from its current location.</p>
 <h3><code>modify(e, 'motion', x, y, z), modify(e, 'motion', l(x,y,z) )</code></h3>
 <p>Sets the motion vector (where an how much entity is moving).</p>
 <h3><code>modify(e, 'motion_z', x), modify(e, 'motion_y', y), modify(e, 'motion_z', z)</code></h3>
 <p>Sets the corresponding component of the motion vector.</p>
 <h3><code>modify(e, 'accelerate', x, y, z), modify(e, 'accelerate', l(x, y, z) )</code></h3>
 <p>Sets adds a vector to the motion vector. Most realistic way to apply a force to an entity.</p>
 <h3><code>modify(e, 'custom_name'), modify(e, 'custom_name', name )</code></h3>
 <p>Sets a custom name for an entity. No argument sets it empty, not removes it. Vanilla doesn't allow removing
 of attributes.</p>
 <h3><code>modify(e, 'dismount')</code></h3>
 <p>Dismounts riding entity.</p>
 <h3><code>modify(e, 'mount', other)</code></h3>
 <p>Mounts the entity to the <code>other</code>.</p>
 <h3><code>modify(e, 'drop_passengers')</code></h3>
 <p>Shakes off all passengers.</p>
 <h3><code>modify(e, 'mount_passengers', passenger, ? ...), modify(e, 'mount_passengers', l(passengers) )</code></h3>
 <p>Mounts on all listed entities on <code>e</code>.</p>
 <h3><code>modify(e, 'tag', tag, ? ...), modify(e, 'tag', l(tags) )</code></h3>
 <p>Adds tag / tags to the entity.</p>
 <h3><code>modify(e, 'clear_tag', tag, ? ...), modify(e, 'clear_tag', l(tags) )</code></h3>
 <p>Removes tag from entity.</p>
 <h3><code>modify(e, 'talk')</code></h3>
 <p>Make noises.</p>
 <h3><code>modify(e, 'home', null), modify(e, 'home', block, distance?), modify(e, 'home', x, y, z, distance?)</code></h3>
 <p>Sets AI to stay around the home position, within <code>distance</code> blocks from it. <code>distance</code>
 defaults to 16 blocks. <code>null</code> removes it. <i>May</i> not work fully with mobs that have this AI built in, like
 Villagers.</p>
 </div></div>
</li>
</ul>
<a name="API_IteratingOverAreasOfBlocks--">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>API_IteratingOverAreasOfBlocks</h4>
<pre>public&nbsp;void&nbsp;API_IteratingOverAreasOfBlocks()</pre>
<div class="block"><h1>Iterating over larger areas of blocks</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>These functions help scan larger areas of blocks without using generic loop functions,
 like nested <code>loop</code>.</p>
 <h2> </h2>
 <h3><code>scan(cx, cy, cz, dx, dy, dz, px?, py?, pz?, expr)</code></h3>
 <p>Evaluates expression over area of blocks defined by its center (<code>cx, cy, cz</code>),
 expanded in all directions by <code>dx, dy, dz</code> blocks, or optionally in negative with <code>d</code> coords,
 and <code>p</code> coords in positive values. <code>expr</code> receives <code>_x, _y, _z</code>
 as coords of current analyzed block and <code>_</code> which represents the block itself.</p>
 <h3><code>volume(x1, y1, z1, x2, y2, z2, expr)</code></h3>
 <p>Evaluates expression for each block in the area, the same as the <code>scan</code>function, but using two opposite
 corners of the rectangular cuboid. Any corners can be specified, its like you would do with <code>/fill</code> command</p>
 <h3><code>neighbours(x, y, z), neighbours(block), neighbours(l(x,y,z))</code></h3>
 <p>Returns the list of 6 neighbouring blocks to the argument. Commonly used with other loop functions like <code>for</code></p>
 <pre>
 for(neighbours(x,y,z),air(_)) =&gt; 4 // number of air blocks around a block
 </pre>
 <h3><code>rect(cx, cy, cz, dx?, dy?, dz?, px?, py?, pz?)</code></h3>
 <p>returns an iterator, just like <code>range</code> function that iterates over rectangular cubarea of blocks. If
 only center point is specified, it iterates over 27 blocks. If <code>d</code> arguments are specified, expands selection
 of respective number of blocks in each direction. If <code>p</code> arguments are specified, it uses <code>d</code> for
 negative offset, and <code>p</code> for positive.</p>
 <h3><code>diamond(cx, cy, cz, radius?, height?)</code></h3>
 <p>Iterates over a diamond like area of blocks. With no radius and height, its 7 blocks centered around the middle
 (block + neighbours). With radius it expands shape on x and z coords, and wit custom height, on z. Any of these can be
 zero as well. radius of 0 makes a stick, height of 0 makes a diamond shape pad.</p>
 </div></div>
</li>
</ul>
<a name="BreakExecutionOfAllScriptsWithCommands-boolean-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>BreakExecutionOfAllScriptsWithCommands</h4>
<pre>public static&nbsp;void&nbsp;BreakExecutionOfAllScriptsWithCommands(boolean&nbsp;doStop)</pre>
<div class="block"><h1><code>script stop/script resume</code> command</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>
 <code>/script stop</code> allows to stop execution of any script currently running that calls the
 <code>gametick()</code> function which
 allows the game loop to regain control of the game and process other commands. This will also make sure
 that all current and future programs will stop their execution. Execution of all programs will be
 prevented until <code>/script resume</code> command is called.
 </p>
 <p>Lets look at the following example. This is a program computes Fibonacci number in a recursive manner:</p>
 <pre>
 fib(n) -&gt; if(n&lt;3, 1, fib(n-1)+fib(n-2) ); fib(8)
 </pre>
 <p> That's really bad way of doing it, because the higher number we need to compute the compute requirements will rise
 exponentially with <code>n</code>. It takes a little over 50 milliseconds to do fib(24), so above one tick,
 but about a minute to do fib(40). Calling fib(40) will not only freeze the game, but also you woudn't be able to interrupt
 its execution. We can modify the script as follows</p>
 <pre>fib(n) -&gt; ( gametick(50); if(n&lt;3, 1, fib(n-1)+fib(n-2) ) ); fib(40)</pre>
 <p>But this would never finish as such call would finish after <code>~ 2^40</code> ticks. To make our computations
 responsive, yet able to respond to user interactions, other commands, as well as interrupt execution,
 we could do the following:</p>
 <pre>fib(n) -&gt; ( if(n==23, gametick(50) ); if(n&lt;3, 1, fib(n-1)+fib(n-2) ) ); fib(40)</pre>
 <p>This would slow down the computation of fib(40) from a minute to two, but allows the game to keep continue running
 and be responsive to commands, using about half of each tick to advance the computation.
 Obviously depending on the problem, and available hardware, certain things can take
 more or less time to execute, so portioning of work with calling <code>gametick</code> should be balanced in each
 case separately</p>
 </div></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>doStop</code> - .</dd>
</dl>
</li>
</ul>
<a name="fillAndScanCommand-int-int-int-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fillAndScanCommand</h4>
<pre>public&nbsp;boolean&nbsp;fillAndScanCommand(int&nbsp;x,
                                  int&nbsp;y,
                                  int&nbsp;z)</pre>
<div class="block"><h1><code>/script scan</code>, <code>/script fill</code> and <code>/script outline</code> commands</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>These commands can be used to evaluate an expression over an area of blocks. They all need to have specified
 the origin of the analyzed area (which is used as referenced (0,0,0), and two corners of an area to analyzed. If
 you would want that the script block coordinates refer to the actual world coordinates, use origin of <code>0 0 0</code>,
 or if it doesn't matter, duplicating coordinates of one of the corners is the easiest way.</p>
 <p>These commands, unlike raw <code>/script run </code> are limited by vanilla fill / clone command
 limit of 32k blocks, which can be altered with carpet mod's own <code>/carpet fillLimit</code> command.</p>
 <h2></h2>
 <h3><code>/script scan origin&lt;x y z&gt;  corner&lt;x y z&gt; corner&lt;x y z&gt; expr</code></h3>
 <p>Evaluates expression for each point in the area and returns number of successes (result was positive). Since
 the command by itself doesn't affect the area, the effects would be in side effects.</p>
 <h3><code>/script fill origin&lt;x y z&gt;  corner&lt;x y z&gt; corner&lt;x y z&gt; "expr" &lt;block&gt; (? replace &lt;replacement&gt;) </code></h3>
 <p>Think of it as a regular fill command, that sets blocks based on whether a result of the command was successful.
 Note that the expression is in quotes. Thankfully string constants in <code>scarpet</code> use single quotes. Can be used
 to fill complex geometric shapes.</p>
 <h3><code>/script outline origin&lt;x y z&gt;  corner&lt;x y z&gt; corner&lt;x y z&gt; "expr" &lt;block&gt; (? replace &lt;replacement&gt;) </code></h3>
 <p>Similar to <code>fill</code> command it evaluates an expression for each block in the area, but in this case setting blocks
 where condition was true and any of the neighbouring blocks were evaluated negatively. This allows to create surface areas,
 like sphere for example, without resorting to various rounding modes and tricks.</p>
 <p>Here is an example of seven ways to draw a sphere of radius of 32 blocks around 0 100 0: </p>
 <pre>
 /script outline 0 100 0 -40 60 -40 40 140 40 "x*x+y*y+z*z &lt;  32*32" white_stained_glass replace air
 /script outline 0 100 0 -40 60 -40 40 140 40 "x*x+y*y+z*z &lt;= 32*32" white_stained_glass replace air
 /script outline 0 100 0 -40 60 -40 40 140 40 "x*x+y*y+z*z &lt;  32.5*32.5" white_stained_glass replace air
 /script fill    0 100 0 -40 60 -40 40 140 40 "floor(sqrt(x*x+y*y+z*z)) == 32" white_stained_glass replace air
 /script fill    0 100 0 -40 60 -40 40 140 40 "round(sqrt(x*x+y*y+z*z)) == 32" white_stained_glass replace air
 /script fill    0 100 0 -40 60 -40 40 140 40 "ceil(sqrt(x*x+y*y+z*z)) == 32" white_stained_glass replace air
 /draw sphere 0 100 0 32 white_stained_glass replace air

 fluffy ball round(sqrt(x*x+y*y+z*z)-rand(abs(y)))==32

 </pre>
 <p>The last method is the one that world edit is using (part of carpet mod). It turns out that the outline method with <code>32.5</code> radius,
 fill method with <code>round</code> function and draw command are equivalent</p>
 </div></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>x</code> - .</dd>
<dd><code>y</code> - .</dd>
<dd><code>z</code> - .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>.</dd>
</dl>
</li>
</ul>
<a name="invokeGlobalFunctionCommand-net.minecraft.command.CommandSource-java.lang.String-java.util.List-java.lang.String-">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>invokeGlobalFunctionCommand</h4>
<pre>public static&nbsp;java.lang.String&nbsp;invokeGlobalFunctionCommand(net.minecraft.command.CommandSource&nbsp;source,
                                                           java.lang.String&nbsp;call,
                                                           java.util.List&lt;java.lang.Integer&gt;&nbsp;coords,
                                                           java.lang.String&nbsp;arg)</pre>
<div class="block"><h1><code>/script invoke / invokepoint / invokearea</code>, <code>/script globals</code> commands</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p><code>invoke</code> family of commands provide convenient way to invoke stored procedures (i.e. functions
 that has been defined previously by any running script. To view current stored procedure set,
 run <code>/script globals</code>, to define a new stored procedure, just run a <code>/script run function(a,b) -&gt; ( ... )</code>
 command with your procedure once, and to forget a procedure, use <code>undef</code> function:
 <code>/script run undef('function')</code></p>
 <h2></h2>
 <h3><code>/script invoke &lt;fun&gt; &lt;args?&gt; ... </code></h3>
 <p>Equivalent of running <code>/script run fun(args, ...)</code>, but you get the benefit of getting the tab completion of the
 command name, and lower permission level required to run these (since player is not capable of running any custom code
 in this case, only this that has been executed before by an operator). Arguments will be checked for validity, and
 you can only pass simple values as arguments (strings, numbers, or <code>null</code> value). Use quotes to include
 whitespaces in argument strings.</p>
 <p>Command will check provided arguments with required arguments (count) and fail if not enough or too much arguments
 are provided. Operators defining functions are advised to use descriptive arguments names, as these will be visible
 for invokers and form the base of understanding what each argument does.</p>
 <p><code>invoke</code> family of commands will tab complete any stored function that does not start with <code>'_'</code>,
 it will still allow to run procedures starting with <code>'_'</code> but not suggest them, and ban execution of any
 hidden stored procedures, so ones that start with <code>'__'</code>. In case operator needs to use subroutines
 for convenience and don't want to expose them to the <code>invoke</code> callers, they can use this mechanic.</p>
 <pre>
 /script run example_function(const, phrase, price) -&gt; print(const+' '+phrase+' '+price)
 /script invoke example_function pi costs 5
 </pre>
 <h3><code>/script invokepoint &lt;fun&gt; &lt;coords x y z&gt; &lt;args?&gt; ... </code></h3>
 <p>It is equivalent to <code>invoke</code> except it assumes that the first three arguments are coordinates, and provides
 coordinates tab completion, with <code>looking at... </code> mechanics for convenience. All other arguments are expected
 at the end</p>
 <h3><code>/script invokearea &lt;fun&gt; &lt;coords x y z&gt; &lt;coords x y z&gt; &lt;args?&gt; ... </code></h3>
 <p>It is equivalent to <code>invoke</code> except it assumes that the first three arguments are one set of ccordinates,
 followed by the second set of coordinates, providing tab completion, with <code>looking at... </code> mechanics for convenience,
 followed by any other required arguments</p>
 </div></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>source</code> - .</dd>
<dd><code>call</code> - .</dd>
<dd><code>coords</code> - .</dd>
<dd><code>arg</code> - .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>.</dd>
</dl>
</li>
</ul>
<a name="scriptRunCommand-net.minecraft.util.math.BlockPos-">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>scriptRunCommand</h4>
<pre>public&nbsp;java.lang.String&nbsp;scriptRunCommand(net.minecraft.util.math.BlockPos&nbsp;pos)</pre>
<div class="block"><h1><code>/script run</code> command</h1>
 <div style="padding-left: 20px; border-radius: 5px 45px; border:1px solid grey;">
 <p>primary way to input commands. The command executes in the context, position, and dimension of the executing
 player, commandblock, etc... The command receives 4 variables, <code>x</code>, <code>y</code>, <code>z</code>
 and <code>p</code> indicating position and the executing entity of the command.
 It is advisable to use <code>/execute in ... at ... as ... run script run ...</code> or similar, to simulate running
 commands in a different scope</p>
 </div></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>pos</code> - .</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>.</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
</body>
</html>
